"""Data retention service for automatic cleanup of old data."""

from datetime import UTC, datetime, timedelta
from typing import Any

import structlog
from sqlalchemy import select, text
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.retention_policy import RetentionPolicy

logger = structlog.get_logger()

# Default retention policies for various tables
DEFAULT_POLICIES = [
    {
        "table_name": "raw_events",
        "display_name": "Events",
        "description": "Raw events collected from log sources (DNS queries, network connections, etc.)",
        "retention_days": 30,
    },
    {
        "table_name": "alerts",
        "display_name": "Alerts",
        "description": "Security alerts generated by detection rules and anomaly detection",
        "retention_days": 90,
    },
    {
        "table_name": "anomaly_detections",
        "display_name": "Anomalies",
        "description": "Detected anomalies from baseline deviation analysis",
        "retention_days": 90,
    },
    {
        "table_name": "audit_logs",
        "display_name": "Audit Logs",
        "description": "User actions and system events for compliance tracking",
        "retention_days": 365,
    },
    {
        "table_name": "device_baselines",
        "display_name": "Device Baselines",
        "description": "Behavioral baselines for device anomaly detection",
        "retention_days": 0,  # Keep forever
    },
    {
        "table_name": "playbook_executions",
        "display_name": "Playbook Executions",
        "description": "History of automated playbook executions",
        "retention_days": 90,
    },
]


class RetentionService:
    """Service for managing data retention policies and cleanup.

    Handles:
    - Policy CRUD operations
    - Automatic data cleanup based on retention periods
    - Statistics on data storage
    """

    def __init__(self, session: AsyncSession):
        """Initialize the retention service.

        Args:
            session: Async database session.
        """
        self.session = session

    async def initialize_default_policies(self) -> int:
        """Create default retention policies if they don't exist.

        Returns:
            Number of policies created.
        """
        created = 0
        for policy_data in DEFAULT_POLICIES:
            result = await self.session.execute(
                select(RetentionPolicy).where(
                    RetentionPolicy.table_name == policy_data["table_name"]
                )
            )
            if not result.scalar_one_or_none():
                policy = RetentionPolicy(**policy_data)
                self.session.add(policy)
                created += 1

        if created > 0:
            await self.session.commit()
            logger.info("retention_policies_initialized", count=created)

        return created

    async def get_all_policies(self) -> list[RetentionPolicy]:
        """Get all retention policies.

        Returns:
            List of retention policies.
        """
        result = await self.session.execute(
            select(RetentionPolicy).order_by(RetentionPolicy.table_name)
        )
        return list(result.scalars().all())

    async def get_policy(self, policy_id: str) -> RetentionPolicy | None:
        """Get a specific retention policy.

        Args:
            policy_id: UUID of the policy.

        Returns:
            The policy or None if not found.
        """
        result = await self.session.execute(
            select(RetentionPolicy).where(RetentionPolicy.id == policy_id)
        )
        return result.scalar_one_or_none()

    async def get_policy_by_table(self, table_name: str) -> RetentionPolicy | None:
        """Get a retention policy by table name.

        Args:
            table_name: Name of the table.

        Returns:
            The policy or None if not found.
        """
        result = await self.session.execute(
            select(RetentionPolicy).where(RetentionPolicy.table_name == table_name)
        )
        return result.scalar_one_or_none()

    async def update_policy(
        self,
        policy_id: str,
        retention_days: int | None = None,
        enabled: bool | None = None,
    ) -> RetentionPolicy | None:
        """Update a retention policy.

        Args:
            policy_id: UUID of the policy.
            retention_days: New retention period in days.
            enabled: Whether the policy is active.

        Returns:
            Updated policy or None if not found.
        """
        policy = await self.get_policy(policy_id)
        if not policy:
            return None

        if retention_days is not None:
            policy.retention_days = retention_days
        if enabled is not None:
            policy.enabled = enabled

        await self.session.commit()
        await self.session.refresh(policy)

        logger.info(
            "retention_policy_updated",
            policy_id=str(policy_id),
            table=policy.table_name,
            days=policy.retention_days,
            enabled=policy.enabled,
        )

        return policy

    async def run_cleanup(
        self, policy_id: str | None = None, dry_run: bool = False
    ) -> dict[str, Any]:
        """Run data cleanup based on retention policies.

        Args:
            policy_id: Optional specific policy to run. If None, runs all enabled.
            dry_run: If True, only return what would be deleted without deleting.

        Returns:
            Dict with cleanup results.
        """
        policies: list[RetentionPolicy]
        if policy_id:
            policy = await self.get_policy(policy_id)
            policies = [policy] if policy else []
        else:
            result = await self.session.execute(
                select(RetentionPolicy).where(RetentionPolicy.enabled.is_(True))
            )
            policies = list(result.scalars().all())

        details: list[dict[str, Any]] = []
        results: dict[str, Any] = {
            "dry_run": dry_run,
            "policies_processed": 0,
            "total_deleted": 0,
            "details": details,
        }

        policies_processed = 0
        total_deleted = 0

        for policy in policies:
            if policy.retention_days == 0:
                # 0 means keep forever
                details.append(
                    {
                        "table": policy.table_name,
                        "status": "skipped",
                        "reason": "retention_days is 0 (keep forever)",
                    }
                )
                continue

            cutoff_date = datetime.now(UTC) - timedelta(days=policy.retention_days)

            try:
                deleted = await self._cleanup_table(policy.table_name, cutoff_date, dry_run)

                if not dry_run:
                    policy.last_run = datetime.now(UTC)
                    policy.deleted_count = deleted

                policies_processed += 1
                total_deleted += deleted
                details.append(
                    {
                        "table": policy.table_name,
                        "status": "success",
                        "cutoff_date": cutoff_date.isoformat(),
                        "deleted": deleted,
                    }
                )

                logger.info(
                    "retention_cleanup_complete" if not dry_run else "retention_cleanup_preview",
                    table=policy.table_name,
                    cutoff=cutoff_date.isoformat(),
                    deleted=deleted,
                )

            except Exception as e:
                logger.error(
                    "retention_cleanup_failed",
                    table=policy.table_name,
                    error=str(e),
                )
                details.append(
                    {
                        "table": policy.table_name,
                        "status": "error",
                        "error": str(e),
                    }
                )

        if not dry_run:
            await self.session.commit()

        results["policies_processed"] = policies_processed
        results["total_deleted"] = total_deleted
        return results

    async def _cleanup_table(
        self, table_name: str, cutoff_date: datetime, dry_run: bool = False
    ) -> int:
        """Clean up old records from a specific table.

        Args:
            table_name: Name of the table.
            cutoff_date: Delete records older than this date.
            dry_run: If True, only count records without deleting.

        Returns:
            Number of records deleted (or would be deleted).
        """
        # Determine the timestamp column based on table
        timestamp_columns = {
            "raw_events": "timestamp",
            "alerts": "created_at",
            "anomaly_detections": "detected_at",
            "audit_logs": "timestamp",
            "device_baselines": "updated_at",
            "playbook_executions": "started_at",
        }

        timestamp_col = timestamp_columns.get(table_name, "created_at")

        if dry_run:
            # Count records that would be deleted
            count_query = text(f"SELECT COUNT(*) FROM {table_name} WHERE {timestamp_col} < :cutoff")
            result = await self.session.execute(count_query, {"cutoff": cutoff_date})
            count = result.scalar()
            return count or 0
        else:
            # Delete old records
            delete_query = text(f"DELETE FROM {table_name} WHERE {timestamp_col} < :cutoff")
            cursor_result = await self.session.execute(delete_query, {"cutoff": cutoff_date})
            # rowcount is available on CursorResult from text() execution
            rowcount: int = getattr(cursor_result, "rowcount", 0) or 0
            return rowcount

    async def get_storage_stats(self) -> dict[str, Any]:
        """Get storage statistics for all retention-managed tables.

        Returns:
            Dict with storage statistics per table.
        """
        tables: list[dict[str, Any]] = []
        total_rows = 0

        policies = await self.get_all_policies()

        for policy in policies:
            try:
                # Get row count
                count_query = text(f"SELECT COUNT(*) FROM {policy.table_name}")
                result = await self.session.execute(count_query)
                row_count: int = result.scalar() or 0

                # Get table size (PostgreSQL specific)
                size_query = text(
                    f"SELECT pg_size_pretty(pg_total_relation_size('{policy.table_name}'))"
                )
                result = await self.session.execute(size_query)
                table_size = result.scalar() or "unknown"

                tables.append(
                    {
                        "table_name": policy.table_name,
                        "display_name": policy.display_name,
                        "row_count": row_count,
                        "table_size": table_size,
                        "retention_days": policy.retention_days,
                        "enabled": policy.enabled,
                        "last_run": policy.last_run.isoformat() if policy.last_run else None,
                        "last_deleted": policy.deleted_count,
                    }
                )
                total_rows += row_count

            except Exception as e:
                logger.warning(
                    "storage_stats_error",
                    table=policy.table_name,
                    error=str(e),
                )
                tables.append(
                    {
                        "table_name": policy.table_name,
                        "display_name": policy.display_name,
                        "error": str(e),
                    }
                )

        return {"tables": tables, "total_rows": total_rows}
